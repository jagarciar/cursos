"use strict";(self.webpackChunkcursos=self.webpackChunkcursos||[]).push([[8204],{2591:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"programacion/reactjs/hooks/useMemo","title":"useMemo","description":"En este tutorial vamos hacer uso del hook useMemo para memorizar el valor de una variable en un proyecto ReactJS","source":"@site/docs/programacion/reactjs/hooks/useMemo.md","sourceDirName":"programacion/reactjs/hooks","slug":"/programacion/reactjs/hooks/useMemo","permalink":"/cursos/docs/programacion/reactjs/hooks/useMemo","draft":false,"unlisted":false,"editUrl":"https://github.com/jagarciar/cursos/tree/main/docs/programacion/reactjs/hooks/useMemo.md","tags":[{"inline":false,"label":"React","permalink":"/cursos/docs/tags/about-react","description":"Tutoriales donde se menciona la palabra react"},{"inline":false,"label":"React JS","permalink":"/cursos/docs/tags/about-react-js","description":"Tutoriales donde se menciona la palabra reactjs"},{"inline":false,"label":"NPM","permalink":"/cursos/docs/tags/about-npm","description":"Tutoriales donde se menciona la palabra npm"},{"inline":false,"label":"Vite","permalink":"/cursos/docs/tags/about-vite","description":"Tutoriales donde se menciona la palabra vite"},{"inline":false,"label":"Componente funcional","permalink":"/cursos/docs/tags/about-functional-component","description":"Tutoriales donde se menciona la palabra componente funcional"},{"inline":false,"label":"hooks","permalink":"/cursos/docs/tags/about-hooks","description":"Tutoriales donde se menciona la palabra hooks"},{"inline":false,"label":"useMemo","permalink":"/cursos/docs/tags/about-useMemo","description":"Tutoriales donde se menciona la palabra useMemo"},{"inline":false,"label":"Memorizaci\xf3n","permalink":"/cursos/docs/tags/about-memorizacion","description":"Tutoriales donde se menciona la palabra memorizaci\xf3n"}],"version":"current","lastUpdatedBy":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","lastUpdatedAt":1745884800000,"sidebarPosition":5,"frontMatter":{"id":"useMemo","title":"useMemo","sidebar_position":5,"author":"jeogarod","description":"En este tutorial vamos hacer uso del hook useMemo para memorizar el valor de una variable en un proyecto ReactJS","tags":["react","reactjs","npm","vite","componente-funcional","hooks","useMemo","memorizacion"],"last_update":{"date":"04/29/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"}},"sidebar":"tutorialSidebar","previous":{"title":"useRef","permalink":"/cursos/docs/programacion/reactjs/hooks/useRef"},"next":{"title":"useCallback","permalink":"/cursos/docs/programacion/reactjs/hooks/useCallback"}}');var s=n(4848),r=n(8453);const t={id:"useMemo",title:"useMemo",sidebar_position:5,author:"jeogarod",description:"En este tutorial vamos hacer uso del hook useMemo para memorizar el valor de una variable en un proyecto ReactJS",tags:["react","reactjs","npm","vite","componente-funcional","hooks","useMemo","memorizacion"],last_update:{date:"04/29/2025",author:"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"}},l="useMemo",i={},c=[];function d(e){const o={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"usememo",children:"useMemo"})}),"\n",(0,s.jsxs)(o.p,{children:["En el contexto de ",(0,s.jsx)(o.strong,{children:"React"}),", ",(0,s.jsx)(o.strong,{children:"memoizaci\xf3n"})," se refiere a la ",(0,s.jsx)(o.strong,{children:"optimizaci\xf3n"})," que se puede aplicar para ",(0,s.jsx)(o.strong,{children:"evitar renderizados innecesarios"})," y ",(0,s.jsx)(o.strong,{children:"mejorar el rendimiento de los componentes"}),". En ",(0,s.jsx)(o.strong,{children:"React"}),", cuando los datos o el estado de un componente cambian, este se vuelve a renderizar para reflejar esos cambios en la interfaz de usuario. Sin embargo, en algunos casos, este proceso puede ser ineficiente si se renderizan componentes hijos que no han experimentado cambios en sus propios datos."]}),"\n",(0,s.jsxs)(o.p,{children:["La ",(0,s.jsx)(o.strong,{children:"memorizaci\xf3n"})," en ",(0,s.jsx)(o.strong,{children:"React"})," se logra utilizando algunos ",(0,s.jsx)(o.strong,{children:"hooks"})," como: ",(0,s.jsx)(o.strong,{children:"useMemo"})," o ",(0,s.jsx)(o.a,{href:"/cursos/docs/programacion/reactjs/hooks/useCallback",children:(0,s.jsx)(o.strong,{children:"useCallback"})}),"."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.strong,{children:"useMemo"})," es un ",(0,s.jsx)(o.strong,{children:"hook"})," que se utiliza para ",(0,s.jsx)(o.strong,{children:"memorizar"})," el ",(0,s.jsx)(o.strong,{children:"resultado"})," de una ",(0,s.jsx)(o.strong,{children:"operaci\xf3n costosa de c\xe1lculo entre re-renderizaciones de un componente funcional"}),". Esto ayuda a optimizar el rendimiento al evitar el rec\xe1lculo innecesario de valores cuando el componente se vuelve a renderizar."]}),"\n",(0,s.jsxs)(o.p,{children:["El archivo ",(0,s.jsx)(o.strong,{children:"/src/MemoApp.jsx"})," exporta el componente funcional ",(0,s.jsx)(o.strong,{children:"MemoApp"}),". El componente ",(0,s.jsx)(o.strong,{children:"MemoApp"})," defini\xf3 dos variables de estado : ",(0,s.jsx)(o.strong,{children:"factorial"})," y ",(0,s.jsx)(o.strong,{children:"clicks"}),". Cada variable de estado tiene su propia funci\xf3n ",(0,s.jsx)(o.strong,{children:"set"})," ",(0,s.jsx)(o.strong,{children:"setFactorial"})," y ",(0,s.jsx)(o.strong,{children:"setClicks"}),". Adicionalmente, el componente ",(0,s.jsx)(o.strong,{children:"MemoApp"})," defini\xf3 dos funciones que capturan los eventos ",(0,s.jsx)(o.strong,{children:"onChange"})," (mediante la funci\xf3n ",(0,s.jsx)(o.strong,{children:"handleChange"}),") y ",(0,s.jsx)(o.strong,{children:"onClick"})," (mediante la funci\xf3n ",(0,s.jsx)(o.strong,{children:"handleClick"}),") del retorno del componente junto a un ",(0,s.jsx)(o.strong,{children:"hook"})," ",(0,s.jsx)(o.strong,{children:"useEffect"})," el cu\xe1l solo mostrar\xe1 por consola cada que se renderiza el componente."]}),"\n",(0,s.jsxs)(o.p,{children:["Para entender el uso del ",(0,s.jsx)(o.strong,{children:"hook"})," ",(0,s.jsx)(o.strong,{children:"useMemo"})," se implement\xf3 la funci\xf3n ",(0,s.jsx)(o.strong,{children:"getFactorial"})," la cu\xe1l recibe como par\xe1metro el n\xfamero sobre el cu\xe1l se debe realizar el c\xe1lculo. La funci\xf3n ",(0,s.jsx)(o.strong,{children:"getFactorial"})," retorna el factorial del n\xfamero enviado como par\xe1metro. Este resultado es memorizado a trav\xe9s del ",(0,s.jsx)(o.strong,{children:"hook"})," ",(0,s.jsx)(o.strong,{children:"useMemo"})," en una variable llamada ",(0,s.jsx)(o.strong,{children:"memorizeFactorial"}),"."]}),"\n",(0,s.jsxs)(o.p,{children:["El componente ",(0,s.jsx)(o.strong,{children:"MemoApp"})," retorna en un parr\xe1fo el n\xfamero sobre el cu\xe1l se debe calcular el factorial, en un segundo parr\xe1fo el resultado del c\xe1lculo, en una caja de texto el valor de la variable de estado ",(0,s.jsx)(o.strong,{children:"factorial"})," la cu\xe1l ejecuta la funci\xf3n ",(0,s.jsx)(o.strong,{children:"handleChange"})," cuando se dispara el evento ",(0,s.jsx)(o.strong,{children:"onChange"})," y un bot\xf3n para que al disparar el evento ",(0,s.jsx)(o.strong,{children:"onClick"})," se ejecute la funci\xf3n ",(0,s.jsx)(o.strong,{children:"handleClick"})," la cu\xe1l actualiza el valor de la variable de estado ",(0,s.jsx)(o.strong,{children:"clicks"}),"."]}),"\n",(0,s.jsxs)(o.p,{children:["Es super importante que tengamos presente que el componente ",(0,s.jsx)(o.strong,{children:"MemoApp"})," tiene dos variables de estado : ",(0,s.jsx)(o.strong,{children:"factorial"})," y ",(0,s.jsx)(o.strong,{children:"clicks"}),". El ",(0,s.jsx)(o.strong,{children:"hook"})," ",(0,s.jsx)(o.strong,{children:"useMemo"})," memoriza el valor del resultado de la funci\xf3n ",(0,s.jsx)(o.strong,{children:"getFactorial"})," a partir del valor de la variable de estado ",(0,s.jsx)(o.strong,{children:"factorial"}),". Es decir, si la variable de estado ",(0,s.jsx)(o.strong,{children:"factorial"})," se actualiza, se vuelve a ejecutar la funci\xf3n ",(0,s.jsx)(o.strong,{children:"getFactorial"}),", de lo contrario, no se actualiza. Entonces si ejecutamos la funci\xf3n ",(0,s.jsx)(o.strong,{children:"handleClick"})," que actualiza el valor de la variable de estado ",(0,s.jsx)(o.strong,{children:"clicks"})," y se mantiene el valor de la variable de estado ",(0,s.jsx)(o.strong,{children:"factorial"}),", la funci\xf3n ",(0,s.jsx)(o.strong,{children:"getFactorial"})," no es nuevamente ejecutada."]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-javascript",metastring:'title="/src/MemoApp.jsx"',children:'import React from \'react\'\nimport { useState, useMemo, useEffect } from \'react\';\n\nexport const MemoApp = () => {\n\n    const [factorial, setFactorial] = useState(1);\n    const [clicks, setClicks] = useState(0);\n\n    const getFactorial = (num) => {\n        console.log("Ejecutando getFactorial()");\n        let resultado = 1;\n        for (let i = 2; i <= num; i++) {\n            resultado *= i;\n        }\n        return resultado;\n    }\n\n    const memorizeFactorial = useMemo(() =>  getFactorial(factorial), [factorial])\n\n    const handleChange = (event) => {\n        setFactorial(event.target.value);\n    }\n\n    const handleClick = (event) => {\n        setClicks(clicks+1);\n        console.log("Se han ejecutado "+clicks+" clicks");\n    }\n\n    useEffect(() => {console.log("Renderizando..")});\n\n    return (\n        <>\n            <p>N\xfamero : {factorial}</p>\n            <p>Factorial : {memorizeFactorial}</p>\n            <input type="number" id="fact" name="fact" value={factorial} onChange={handleChange}/>\n            <button onClick={handleClick}>Calcular</button>\n        </>\n    )\n}\n'})}),"\n",(0,s.jsxs)(o.p,{children:["Si el componente ",(0,s.jsx)(o.strong,{children:"MemoApp"})," no memorizara a trav\xe9s del ",(0,s.jsx)(o.strong,{children:"hook"})," ",(0,s.jsx)(o.strong,{children:"useMemo"})," el valor del resultado del c\xe1lculo del factorial, cada que se realice un click sobre el bot\xf3n, se volver\xeda a ejecutar a\xfan si se mantiene el mismo valor de la variable de estado ",(0,s.jsx)(o.strong,{children:"factorial"}),"."]})]})}function u(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>t,x:()=>l});var a=n(6540);const s={},r=a.createContext(s);function t(e){const o=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),a.createElement(r.Provider,{value:o},e.children)}}}]);
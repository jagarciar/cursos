"use strict";(self.webpackChunkcursos=self.webpackChunkcursos||[]).push([[3147],{2323:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"reactjs/useEffect","title":"11. useEffect","description":"\xbfQu\xe9 es useEffect? \xbfC\xf3mo aporta en un componente funcional?","source":"@site/docs/reactjs/useEffect.md","sourceDirName":"reactjs","slug":"/reactjs/useEffect","permalink":"/cursos/docs/reactjs/useEffect","draft":false,"unlisted":false,"editUrl":"https://github.com/jagarciar/cursos/tree/main/docs/reactjs/useEffect.md","tags":[{"inline":false,"label":"React","permalink":"/cursos/docs/tags/about-react","description":"Tutoriales donde se menciona la palabra react"},{"inline":false,"label":"React JS","permalink":"/cursos/docs/tags/about-react-js","description":"Tutoriales donde se menciona la palabra reactjs"},{"inline":false,"label":"NPM","permalink":"/cursos/docs/tags/about-npm","description":"Tutoriales donde se menciona la palabra npm"},{"inline":false,"label":"Vite","permalink":"/cursos/docs/tags/about-vite","description":"Tutoriales donde se menciona la palabra vite"},{"inline":false,"label":"Componente funcional","permalink":"/cursos/docs/tags/about-functional-component","description":"Tutoriales donde se menciona la palabra componente funcional"},{"inline":false,"label":"useEffect","permalink":"/cursos/docs/tags/about-useEffect","description":"Tutoriales donde se menciona la palabra useEffect"},{"inline":false,"label":"hooks","permalink":"/cursos/docs/tags/about-hooks","description":"Tutoriales donde se menciona la palabra componente hooks"}],"version":"current","lastUpdatedBy":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","lastUpdatedAt":1745452800000,"sidebarPosition":11,"frontMatter":{"id":"useEffect","title":"11. useEffect","sidebar_position":11,"author":"jeogarod","description":"\xbfQu\xe9 es useEffect? \xbfC\xf3mo aporta en un componente funcional?","tags":["react","reactjs","npm","vite","componente-funcional","useEffect","hooks"],"last_update":{"date":"04/24/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"}},"sidebar":"tutorialSidebar","previous":{"title":"10. useState","permalink":"/cursos/docs/reactjs/useState"},"next":{"title":"12. Custom hooks","permalink":"/cursos/docs/reactjs/custom-hooks"}}');var a=s(4848),t=s(8453);const r={id:"useEffect",title:"11. useEffect",sidebar_position:11,author:"jeogarod",description:"\xbfQu\xe9 es useEffect? \xbfC\xf3mo aporta en un componente funcional?",tags:["react","reactjs","npm","vite","componente-funcional","useEffect","hooks"],last_update:{date:"04/24/2025",author:"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"}},c="11. useEffect",i={},l=[{value:"Loops en la renderizaci\xf3n",id:"loops-en-la-renderizaci\xf3n",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"11-useeffect",children:"11. useEffect"})}),"\n",(0,a.jsxs)(n.p,{children:["El ",(0,a.jsx)(n.strong,{children:"useEffect"})," en React es un tipo de hook que se incorpor\xf3 en la versi\xf3n de React 16.8. Como su nombre lo indica, este hook nos permite definir efectos. Los efectos en esta librer\xeda de JavaScript nos permiten ejecutar un trozo de c\xf3digo seg\xfan el momento en el que se encuentre el ciclo de vida de nuestro componente. ",(0,a.jsx)(n.strong,{children:"useEffect"})," recibe como par\xe1metro una funci\xf3n que se ejecutar\xe1 cada vez que nuestro componente se renderice, ya sea por un ",(0,a.jsx)(n.strong,{children:"cambio de estado"}),", por ",(0,a.jsx)(n.strong,{children:"recibir props nuevas"})," o, y esto es importante, porque es la ",(0,a.jsx)(n.strong,{children:"primera vez que se monta"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["Con el hook ",(0,a.jsx)(n.strong,{children:"useEffect"})," en React, tambi\xe9n podemos ejecutar trozos en las otras fases del ciclo de vida, ya sea en ",(0,a.jsx)(n.strong,{children:"updating"})," o en ",(0,a.jsx)(n.strong,{children:"unmounting"}),". En este orden de ideas, el hook ",(0,a.jsx)(n.strong,{children:"useEffect"})," en React equivale a una combinaci\xf3n de las funciones ",(0,a.jsx)(n.strong,{children:"componentDidMount"}),", ",(0,a.jsx)(n.strong,{children:"componentDidUpdate"})," y ",(0,a.jsx)(n.strong,{children:"componentWillUnmount"}),"."]}),(0,a.jsx)(n.p,{children:"Para poder usarlo debes importarlo al inicio de nuestro Componente."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import React, { useEffect } from 'react'\n"})})]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Otro caso de uso muy t\xedpico de ",(0,a.jsx)(n.strong,{children:"useEffect"})," es la suscripci\xf3n a los eventos del DOM. Por ejemplo, puede ser \xfatil para subscribirnos al evento de scroll, o el de Intersection Observer para crear f\xe1cilmente un componente que sirva de Lazy Load\u2026 o simplemente para escuchar el evento resize del window"]})}),"\n",(0,a.jsxs)(n.p,{children:["Supongamos el siguiente ejemplo: Fue creado el componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," en el archivo ",(0,a.jsx)(n.strong,{children:"/src/RelojApp.jsx"}),". El componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," tiene una variable de estado nombrada ",(0,a.jsx)(n.strong,{children:"segundos"}),". A su vez, defini\xf3 la funci\xf3n ",(0,a.jsx)(n.strong,{children:"setSegundos"})," para actualizar el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Se implement\xf3 la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"})," la cu\xe1l no recibe ning\xfan par\xe1metro e invoca la funci\xf3n ",(0,a.jsx)(n.strong,{children:"setSegundos"})," aumentando el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"})," en 1."]}),"\n",(0,a.jsxs)(n.p,{children:["Finalmente el componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," retorna en un elemento ",(0,a.jsx)(n.strong,{children:"HTML"})," un parr\xe1fo que concatena el contenido Han transcurrido X segundos, donde X debe ser el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setSegundos(segundos + 1);\n  }\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Si ejecutamos el componente tal cu\xe1l como esta hasta el momento, nunca se actualizar\xe1 la variable de estado ",(0,a.jsx)(n.strong,{children:"segundos"}),". Esto dado que no existe ning\xfan evento que desencadene su actualizaci\xf3n."]}),"\n",(0,a.jsxs)(n.p,{children:["Partiendo de que es necesario actualizar el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"})," despu\xe9s de cada renderizaci\xf3n del componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," podemos adicionar el hook ",(0,a.jsx)(n.strong,{children:"useEffect"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Al referenciar en ",(0,a.jsx)(n.strong,{children:"useEffect"})," la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"}),", cada que se renderice el componente, se invocar\xe1 la funci\xf3n actualizando el valor de la variable de estado ",(0,a.jsx)(n.strong,{children:"segundos"}),". A\xfan cuando esta alternativa es valida, encontraremos al probar nuevamente que se queda en un loop infinito de renderizaci\xf3n."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setSegundos(segundos + 1);\n  }\n\n  useEffect(actualizarSegundos)\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"loops-en-la-renderizaci\xf3n",children:"Loops en la renderizaci\xf3n"}),"\n",(0,a.jsx)(n.p,{children:"Por defecto los efectos se disparan cada vez que se realiza un nuevo renderizado pero podemos evitar que el efecto se vuelva a ejecutar pas\xe1ndole un segundo par\xe1metro al hook. El par\xe1metro es un array con todos los valores de los que depende nuestro efecto, de forma que s\xf3lo se ejecutar\xe1 cuando ese valor cambie."}),"\n",(0,a.jsxs)(n.p,{children:["Esto se soluciona adicionando al hoook ",(0,a.jsx)(n.strong,{children:"useEffect"})," un arreglo de aquellas variables de estado que al cambiar su valor deben ejecutar el evento."]}),"\n",(0,a.jsxs)(n.p,{children:["En nuestro ejemplo, para invocar la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"})," en el hook ",(0,a.jsx)(n.strong,{children:"useEffect"})," dependemos de la actualizaci\xf3n del valor de la variable de estado ",(0,a.jsx)(n.strong,{children:"segundos"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setSegundos(segundos + 1);\n  }\n\n  useEffect(actualizarSegundos, [segundos])\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Si probamos nuestro componente hasta aqu\xed, pareciera que a\xfan se mantiene la ejecuci\xf3n del loop infinito de renderizaci\xf3n pero no es asi. En este caso, despu\xe9s de incluir las variables dependientes, el tiempo de ejecuci\xf3n de la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"})," es tan r\xe1pida que simula o sugiere un loop."]}),"\n",(0,a.jsx)(n.p,{children:"Adicionemos un timeout a la ejecuci\xf3n para que no se ejecute inmediatamente sino cada 5 segundos:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setTimeout(() => {  setSegundos(segundos + 5); }, 5000);\n  }\n\n  useEffect(actualizarSegundos, [segundos])\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var o=s(6540);const a={},t=o.createContext(a);function r(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);
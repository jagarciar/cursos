"use strict";(self.webpackChunkcursos=self.webpackChunkcursos||[]).push([[110],{8280:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"reactjs/hooks/useEffect","title":"3. useEffect","description":"useEffect es un hook en ReactJS que permite ejecutar una funci\xf3n despu\xe9s del renderizado de un componente","source":"@site/docs/reactjs/hooks/useEffect.md","sourceDirName":"reactjs/hooks","slug":"/reactjs/hooks/useEffect","permalink":"/cursos/docs/reactjs/hooks/useEffect","draft":false,"unlisted":false,"editUrl":"https://github.com/jagarciar/cursos/tree/main/docs/reactjs/hooks/useEffect.md","tags":[{"inline":false,"label":"React","permalink":"/cursos/docs/tags/about-react","description":"Tutoriales donde se menciona la palabra react"},{"inline":false,"label":"React JS","permalink":"/cursos/docs/tags/about-react-js","description":"Tutoriales donde se menciona la palabra reactjs"},{"inline":false,"label":"NPM","permalink":"/cursos/docs/tags/about-npm","description":"Tutoriales donde se menciona la palabra npm"},{"inline":false,"label":"Vite","permalink":"/cursos/docs/tags/about-vite","description":"Tutoriales donde se menciona la palabra vite"},{"inline":false,"label":"Componente funcional","permalink":"/cursos/docs/tags/about-functional-component","description":"Tutoriales donde se menciona la palabra componente funcional"},{"inline":false,"label":"useEffect","permalink":"/cursos/docs/tags/about-useEffect","description":"Tutoriales donde se menciona la palabra useEffect"},{"inline":false,"label":"hooks","permalink":"/cursos/docs/tags/about-hooks","description":"Tutoriales donde se menciona la palabra hooks"},{"inline":false,"label":"Ciclo de vida","permalink":"/cursos/docs/tags/about-ciclo-vida","description":"Tutoriales donde se menciona la palabra ciclo de vida"},{"inline":false,"label":"Montaje","permalink":"/cursos/docs/tags/about-montaje","description":"Tutoriales donde se menciona la palabra montaje"},{"inline":false,"label":"Desmontaje","permalink":"/cursos/docs/tags/about-desmontaje","description":"Tutoriales donde se menciona la palabra desmontaje"},{"inline":false,"label":"Renderizado","permalink":"/cursos/docs/tags/about-renderizado","description":"Tutoriales donde se menciona la palabra renderizado"}],"version":"current","lastUpdatedBy":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","lastUpdatedAt":1745452800000,"sidebarPosition":3,"frontMatter":{"id":"useEffect","title":"3. useEffect","sidebar_position":3,"author":"jeogarod","description":"useEffect es un hook en ReactJS que permite ejecutar una funci\xf3n despu\xe9s del renderizado de un componente","tags":["react","reactjs","npm","vite","componente-funcional","useEffect","hooks","ciclo-vida","montaje","desmontaje","renderizado"],"last_update":{"date":"04/24/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"}},"sidebar":"tutorialSidebar","previous":{"title":"2. useState","permalink":"/cursos/docs/reactjs/hooks/useState"},"next":{"title":"4. useRef","permalink":"/cursos/docs/reactjs/hooks/useRef"}}');var a=o(4848),r=o(8453);const t={id:"useEffect",title:"3. useEffect",sidebar_position:3,author:"jeogarod",description:"useEffect es un hook en ReactJS que permite ejecutar una funci\xf3n despu\xe9s del renderizado de un componente",tags:["react","reactjs","npm","vite","componente-funcional","useEffect","hooks","ciclo-vida","montaje","desmontaje","renderizado"],last_update:{date:"04/24/2025",author:"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"}},i="3. useEffect",c={},d=[{value:"Ciclo de vida",id:"ciclo-de-vida",level:2},{value:"Montaje",id:"montaje",level:3},{value:"Renderizado",id:"renderizado",level:4},{value:"Actualizaci\xf3n",id:"actualizaci\xf3n",level:3},{value:"Desmontaje",id:"desmontaje",level:3},{value:"Tips",id:"tips",level:2},{value:"Loops en la renderizaci\xf3n",id:"loops-en-la-renderizaci\xf3n",level:3},{value:"Consumo de API&#39;s",id:"consumo-de-apis",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"3-useeffect",children:"3. useEffect"})}),"\n",(0,a.jsxs)(n.p,{children:["El ",(0,a.jsx)(n.strong,{children:"useEffect"})," en React es un tipo de hook que se incorpor\xf3 en la versi\xf3n de React 16.8. Como su nombre lo indica, este hook nos permite definir ",(0,a.jsx)(n.strong,{children:"efectos"}),". Los efectos en esta librer\xeda de JavaScript nos permiten ejecutar un trozo de c\xf3digo seg\xfan el momento en el que se encuentre el ",(0,a.jsx)(n.strong,{children:"ciclo de vida"})," de nuestro componente. ",(0,a.jsx)(n.strong,{children:"useEffect"})," recibe como par\xe1metro una funci\xf3n que se ejecutar\xe1 cada vez que nuestro componente se renderice, ya sea por un ",(0,a.jsx)(n.strong,{children:"cambio de estado"}),", por ",(0,a.jsx)(n.strong,{children:"recibir props nuevas"})," o, y esto es importante, porque es la ",(0,a.jsx)(n.strong,{children:"primera vez que se monta"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["Con el hook ",(0,a.jsx)(n.strong,{children:"useEffect"})," en React, tambi\xe9n podemos ejecutar trozos en las otras fases del ciclo de vida, ya sea en ",(0,a.jsx)(n.strong,{children:"updating"})," o en ",(0,a.jsx)(n.strong,{children:"unmounting"}),". En este orden de ideas, el hook ",(0,a.jsx)(n.strong,{children:"useEffect"})," en React equivale a una combinaci\xf3n de las funciones ",(0,a.jsx)(n.strong,{children:"componentDidMount"}),", ",(0,a.jsx)(n.strong,{children:"componentDidUpdate"})," y ",(0,a.jsx)(n.strong,{children:"componentWillUnmount"}),"."]}),(0,a.jsx)(n.p,{children:"Para poder usarlo debes importarlo al inicio de nuestro Componente."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import React, { useEffect } from 'react'\n"})})]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Otro caso de uso muy t\xedpico de ",(0,a.jsx)(n.strong,{children:"useEffect"})," es la suscripci\xf3n a los eventos del DOM. Por ejemplo, puede ser \xfatil para subscribirnos al evento de scroll, o el de Intersection Observer para crear f\xe1cilmente un componente que sirva de Lazy Load\u2026 o simplemente para escuchar el evento resize del window"]})}),"\n",(0,a.jsxs)(n.p,{children:["Supongamos el siguiente ejemplo: Fue creado el componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," en el archivo ",(0,a.jsx)(n.strong,{children:"/src/RelojApp.jsx"}),". El componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," tiene una variable de estado nombrada ",(0,a.jsx)(n.strong,{children:"segundos"}),". A su vez, defini\xf3 la funci\xf3n ",(0,a.jsx)(n.strong,{children:"setSegundos"})," para actualizar el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Se implement\xf3 la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"})," la cu\xe1l no recibe ning\xfan par\xe1metro e invoca la funci\xf3n ",(0,a.jsx)(n.strong,{children:"setSegundos"})," aumentando el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"})," en 1."]}),"\n",(0,a.jsxs)(n.p,{children:["Finalmente el componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," retorna en un elemento ",(0,a.jsx)(n.strong,{children:"HTML"})," un parr\xe1fo que concatena el contenido Han transcurrido X segundos, donde X debe ser el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setSegundos(segundos + 1);\n  }\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Si ejecutamos el componente tal cu\xe1l como esta hasta el momento, nunca se actualizar\xe1 la variable de estado ",(0,a.jsx)(n.strong,{children:"segundos"}),". Esto dado que no existe ning\xfan evento que desencadene su actualizaci\xf3n."]}),"\n",(0,a.jsxs)(n.p,{children:["Partiendo de que es necesario actualizar el valor de la variable ",(0,a.jsx)(n.strong,{children:"segundos"})," despu\xe9s de cada renderizaci\xf3n del componente ",(0,a.jsx)(n.strong,{children:"Reloj"})," podemos adicionar el hook ",(0,a.jsx)(n.strong,{children:"useEffect"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Al referenciar en ",(0,a.jsx)(n.strong,{children:"useEffect"})," la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"}),", cada que se renderice el componente, se invocar\xe1 la funci\xf3n actualizando el valor de la variable de estado ",(0,a.jsx)(n.strong,{children:"segundos"}),". A\xfan cuando esta alternativa es valida, encontraremos al probar nuevamente que se queda en un loop infinito de renderizaci\xf3n."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setSegundos(segundos + 1);\n  }\n\n  useEffect(actualizarSegundos)\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ciclo-de-vida",children:"Ciclo de vida"}),"\n",(0,a.jsxs)(n.p,{children:["El ",(0,a.jsx)(n.strong,{children:"ciclo de vida"})," (life cycle) de un componente, representa las ",(0,a.jsx)(n.strong,{children:"etapas"})," por las que un componente pasa durante toda su vida, desde la ",(0,a.jsx)(n.strong,{children:"creaci\xf3n"})," hasta que es ",(0,a.jsx)(n.strong,{children:"destruido"}),". Conocer el ciclo de vida de un componente es muy importante debido a que nos permite saber c\xf3mo es que un componente se comporta durante todo su tiempo de vida y nos permite prevenir la gran mayor\xeda de los errores que se provocan en tiempo de ejecuci\xf3n."]}),"\n",(0,a.jsx)(n.h3,{id:"montaje",children:"Montaje"}),"\n",(0,a.jsxs)(n.p,{children:["En React, el ",(0,a.jsx)(n.strong,{children:"montaje"})," es el proceso por medio del cual el componente es ",(0,a.jsx)(n.strong,{children:"construido"})," y renderizado en pantalla por primera vez, por lo tanto, se considera montado solo cuando el componente ya es visible en pantalla y ya es parte del ",(0,a.jsx)(n.strong,{children:"Document Object Model"})," (",(0,a.jsx)(n.strong,{children:"DOM"}),")."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Es el lugar perfecto para realizar llamadas a APIs o cargar datos iniciales desde una base de datos."})}),"\n",(0,a.jsx)(n.h4,{id:"renderizado",children:"Renderizado"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Renderizado"})," significa que React est\xe1 llamando a tu componente, que es una funci\xf3n. El ",(0,a.jsx)(n.strong,{children:"JSX"})," que devuelves de esa funci\xf3n es como una ",(0,a.jsx)(n.strong,{children:"instant\xe1nea de la UI en el tiempo"}),". Tus props, controladores de eventos y variables locales fueron todos calculados usando su estado en el momento del renderizado."]})}),"\n",(0,a.jsxs)(n.p,{children:["Teniendo en cuenta la definici\xf3n de ",(0,a.jsx)(n.strong,{children:"renderizado"}),", vamos a explicar qu\xe9 significa el renderizado inicial y qu\xe9 sucede despu\xe9s de dicho renderizado."]}),"\n",(0,a.jsxs)(n.p,{children:["El ",(0,a.jsx)(n.strong,{children:"renderizado inicial"})," es el cargue inicial de un ",(0,a.jsx)(n.strong,{children:"componente funcional"})," y/o ",(0,a.jsx)(n.strong,{children:"componente de clase"}),". Frameworks y sandboxes a veces ocultan este c\xf3digo, pero se hace con una llamada a ",(0,a.jsx)(n.strong,{children:"createRoot"})," con el nodo ",(0,a.jsx)(n.strong,{children:"DOM"})," de destino, y luego con otra llamada a su m\xe9todo ",(0,a.jsx)(n.strong,{children:"render"})," con tu componente."]}),"\n",(0,a.jsxs)(n.p,{children:["Por ejemplo, Cuando creamos un aplicativo y/o proyecto ",(0,a.jsx)(n.strong,{children:"React"})," haciendo uso de ",(0,a.jsx)(n.strong,{children:"Vite"}),", se crea un archivo ",(0,a.jsx)(n.strong,{children:"/src/main.jsx"})," el cu\xe1l invoca la funci\xf3n ",(0,a.jsx)(n.strong,{children:"createRoot"})," y ",(0,a.jsx)(n.strong,{children:"render"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/main.jsx"',children:"import { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport { Carro } from './ComponenteApp'\n\ncreateRoot(document.getElementById('root')).render(\n  <StrictMode>\n\n  </StrictMode>,\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Una vez que el componente ha sido renderizado inicialmente, puede desencadenar m\xe1s renderizados ",(0,a.jsx)(n.strong,{children:"actualizando su estado"})," con la funci\xf3n ",(0,a.jsx)(n.strong,{children:"set"}),". Al actualizar el estado de tu componente, se pone en cola autom\xe1ticamente un renderizado. Recordemos que la funci\xf3n ",(0,a.jsx)(n.strong,{children:"set"})," hace parte de la definici\xf3n de ",(0,a.jsx)(n.a,{href:"/cursos/docs/reactjs/hooks/useState",children:"useState"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Este proceso es recursivo: si el componente actualizado devuelve alg\xfan otro componente, React renderizar\xe1 ese componente a continuaci\xf3n, y si ese componente tambi\xe9n devuelve algo, renderizar\xe1 ese componente a continuaci\xf3n, y as\xed sucesivamente. El proceso continuar\xe1 hasta que no haya m\xe1s componentes anidados y React sepa exactamente qu\xe9 debe mostrarse en pantalla."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Para el renderizado inicial, React utilizar\xe1 la API del DOM ",(0,a.jsx)(n.strong,{children:"appendChild()"})," para poner en pantalla todos los nodos del DOM que ha creado."]}),"\n",(0,a.jsx)(n.li,{children:"React s\xf3lo cambia los nodos del DOM si hay una diferencia entre los renderizados."}),"\n",(0,a.jsx)(n.li,{children:"Despu\xe9s de que el renderizado haya terminado y React haya actualizado el DOM, el navegador volver\xe1 a pintar la pantalla"}),"\n"]})}),"\n",(0,a.jsx)(n.h3,{id:"actualizaci\xf3n",children:"Actualizaci\xf3n"}),"\n",(0,a.jsxs)(n.p,{children:["En +",(0,a.jsx)(n.strong,{children:"React"}),", la ",(0,a.jsx)(n.strong,{children:"actualizaci\xf3n"})," es el proceso por medio del cual un componte ya montado es ",(0,a.jsx)(n.strong,{children:"actualizado"}),", ya sea por cambiar el ",(0,a.jsx)(n.strong,{children:"estado"})," o las ",(0,a.jsx)(n.strong,{children:"props"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["Durante la actualizaci\xf3n se comparan las ",(0,a.jsx)(n.strong,{children:"props"})," y el ",(0,a.jsx)(n.strong,{children:"estado"})," actual con los anteriores para determinar si alguna acci\xf3n espec\xedfica debe llevarse a cabo. Por ejemplo, se pueden hacer peticiones a una API para obtener nuevos datos si los ",(0,a.jsx)(n.strong,{children:"props"})," cambian o actualizar ciertos valores en funci\xf3n del ",(0,a.jsx)(n.strong,{children:"estado"}),"."]}),(0,a.jsxs)(n.p,{children:["Si el efecto realiza ",(0,a.jsx)(n.strong,{children:"tareas asincr\xf3nicas"})," (como llamadas a API), ten en cuenta que no puedes usar ",(0,a.jsx)(n.strong,{children:"async"})," directamente en el cuerpo del efecto. En su lugar, puedes definir una ",(0,a.jsx)(n.strong,{children:"funci\xf3n asincr\xf3nica"})," dentro del efecto y llamarla inmediatamente"]})]}),"\n",(0,a.jsx)(n.h3,{id:"desmontaje",children:"Desmontaje"}),"\n",(0,a.jsxs)(n.p,{children:["En ",(0,a.jsx)(n.strong,{children:"React"}),", el ",(0,a.jsx)(n.strong,{children:"desmontaje"})," es el proceso por medio del cual un componte es ",(0,a.jsx)(n.strong,{children:"destruido"})," y finalmente removido del ",(0,a.jsx)(n.strong,{children:"Document Object Model"})," (",(0,a.jsx)(n.strong,{children:"DOM"}),"), lo que implica que no sea visible en pantalla."]}),"\n",(0,a.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,a.jsx)(n.h3,{id:"loops-en-la-renderizaci\xf3n",children:"Loops en la renderizaci\xf3n"}),"\n",(0,a.jsx)(n.p,{children:"Por defecto los efectos se disparan cada vez que se realiza un nuevo renderizado pero podemos evitar que el efecto se vuelva a ejecutar pas\xe1ndole un segundo par\xe1metro al hook. El par\xe1metro es un array con todos los valores de los que depende nuestro efecto, de forma que s\xf3lo se ejecutar\xe1 cuando ese valor cambie."}),"\n",(0,a.jsxs)(n.p,{children:["Esto se soluciona adicionando al hoook ",(0,a.jsx)(n.strong,{children:"useEffect"})," un arreglo de aquellas variables de estado que al cambiar su valor deben ejecutar el evento."]}),"\n",(0,a.jsxs)(n.p,{children:["En nuestro ejemplo, para invocar la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"})," en el hook ",(0,a.jsx)(n.strong,{children:"useEffect"})," dependemos de la actualizaci\xf3n del valor de la variable de estado ",(0,a.jsx)(n.strong,{children:"segundos"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setSegundos(segundos + 1);\n  }\n\n  useEffect(actualizarSegundos, [segundos])\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Si probamos nuestro componente hasta aqu\xed, pareciera que a\xfan se mantiene la ejecuci\xf3n del loop infinito de renderizaci\xf3n pero no es asi. En este caso, despu\xe9s de incluir las variables dependientes, el tiempo de ejecuci\xf3n de la funci\xf3n ",(0,a.jsx)(n.strong,{children:"actualizarSegundos"})," es tan r\xe1pida que simula o sugiere un loop."]}),"\n",(0,a.jsx)(n.p,{children:"Adicionemos un timeout a la ejecuci\xf3n para que no se ejecute inmediatamente sino cada 5 segundos:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/RelojApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Reloj = () => {\n\n  const [segundos, setSegundos] = useState(0)\n\n  const actualizarSegundos = () => {\n    setTimeout(() => {  setSegundos(segundos + 5); }, 5000);\n  }\n\n  useEffect(actualizarSegundos, [segundos])\n\n  return (\n    <>\n        <p>Han transcurrido {segundos} segundos</p>\n    </>\n  )\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"consumo-de-apis",children:"Consumo de API's"}),"\n",(0,a.jsxs)(n.p,{children:["En el siguiente ejemplo vamos a consumir una ",(0,a.jsx)(n.strong,{children:"API REST"})," expuesta p\xfablicamente bajo la URL ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://pokeapi.co/api/v2/type/3",children:"https://pokeapi.co/api/v2/type/3"})}),". Esta API esta expuesta bajo un m\xe9todo *",(0,a.jsx)(n.strong,{children:"HTTP GET"}),". El resultado del consumo ser\xe1 almacenado en una variable de estado llamada ",(0,a.jsx)(n.strong,{children:"pokemones"})," a trav\xe9s de su funci\xf3n ",(0,a.jsx)(n.strong,{children:"setPokemones"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["En este ejemplo, a partir de ",(0,a.jsx)(n.strong,{children:"useEffect"})," se invoc\xf3 el consumo de una ",(0,a.jsx)(n.strong,{children:"API REST"})," haciendo uso de ",(0,a.jsx)(n.strong,{children:"fetch"}),". La funci\xf3n ",(0,a.jsx)(n.strong,{children:"fetch"})," recibe el ",(0,a.jsx)(n.strong,{children:"endpoint"})," de la ",(0,a.jsx)(n.strong,{children:"API"})," y retorna la respuesta en formato ",(0,a.jsx)(n.strong,{children:"JSON"}),". El ",(0,a.jsx)(n.strong,{children:"hook"})," ",(0,a.jsx)(n.strong,{children:"useEffect"})," depender\xe1 del valor cambiante de la variable de estado ",(0,a.jsx)(n.strong,{children:"pokemones"})," para hacer nuevamente el llamado."]}),"\n",(0,a.jsx)(n.p,{children:"Finalmente se muestran los nombres de los pokemones obtenidos."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",metastring:'title="/src/PokemonApp.jsx"',children:"import { useState, useEffect } from 'react';\nimport React from 'react'\n\nexport const Pokemon = () => {\n\n    const url = \"https://pokeapi.co/api/v2/type/3\";\n    const [pokemones, setPokemones] = useState([])\n\n    useEffect(() => {\n        fetch(url)\n            .then(response => response.json())\n            // 4. Setting *dogImage* to the image url that we received from the response above\n            .then(data => setPokemones(data.pokemon)).catch((error) => {\n                console.error(error);\n            })\n    }, [pokemones])\n\n    return (\n        <>\n          Hay {pokemones.length} pokemones\n            <ul>\n                {pokemones.map((pokemon) =>  <li key={pokemon.pokemon.name} value={pokemon.pokemon.name}>{pokemon.pokemon.name}</li> )}\n            </ul>\n        </>\n    )\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>t,x:()=>i});var s=o(6540);const a={},r=s.createContext(a);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
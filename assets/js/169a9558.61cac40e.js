"use strict";(self.webpackChunkcursos=self.webpackChunkcursos||[]).push([[2993],{8885:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"api-first","metadata":{"permalink":"/cursos/blog/api-first","source":"@site/blog/2025-05-19-API-First.md","title":"API First","description":"API First es una estrateg\xeda que prioriza la definici\xf3n e implementaci\xf3n de API\'s antes del dise\xf1o de UI.","date":"2025-05-19T00:00:00.000Z","tags":[{"inline":false,"label":"API REST","permalink":"/cursos/blog/tags/about-api-rest","description":"Tutoriales donde se menciona la palabra API REST"},{"inline":false,"label":"API First","permalink":"/cursos/blog/tags/about-api-first","description":"Tutoriales donde se menciona la palabra API First"},{"inline":false,"label":"Patrones de software","permalink":"/cursos/blog/tags/about-patron-software","description":"Tutoriales donde se menciona la palabra patrones de desarrollo o dise\xf1o de software"}],"readingTime":1.74,"hasTruncateMarker":true,"authors":[{"name":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","title":"Ing. de Sistemas","url":"https://github.com/jagarciar","page":null,"socials":{"github":"https://github.com/jagarciar"},"imageURL":"https://github.com/jagarciar.png","key":"jeogarod"}],"frontMatter":{"id":"api-first","Titule":"API First","description":"API First es una estrateg\xeda que prioriza la definici\xf3n e implementaci\xf3n de API\'s antes del dise\xf1o de UI.","authors":["jeogarod"],"sidebar_position":4,"slug":"api-first","tags":["api-rest","api-first","patron-software"],"last_update":{"date":"05/19/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"},"hide_table_of_contents":false},"unlisted":false,"nextItem":{"title":"Principio de responsabilidad \xfanica","permalink":"/cursos/blog/srp"}},"content":"**API First** es una **estrategia** de **desarrollo de aplicaciones** en la que el **dise\xf1o** y **desarrollo** de las **API** tienen prioridad sobre otros componentes de software, coloc\xe1ndolos a la vanguardia del proceso de desarrollo desde el principio.\\n\\nEl concepto de **API First** implica que todos los componentes de una aplicaci\xf3n, incluyendo el **frontend**, el **backend**, y cualquier integraci\xf3n con sistemas externos, deben estar alineados y comunicarse a trav\xe9s de APIs bien definidas. Esto garantiza que la API sea un contrato estable y confiable que otros desarrolladores, tanto internos como externos, pueden utilizar sin preocuparse por cambios inesperados.\\n\\n\x3c!-- truncate --\x3e\\n\\n:::tip\\nPara **API First**, las **API** son el n\xfacleo alrededor del cual se construye todo el ecosistema de software. Esto contrasta con enfoques m\xe1s tradicionales donde la API puede ser desarrollada como una necesidad secundaria o incluso omitida por completo en las primeras etapas de un proyecto.\\n:::\\n\\nUno de los principales beneficios de **API First** es la mejora en la colaboraci\xf3n entre los diferentes equipos de desarrollo. Dado que las **API** est\xe1n definidas desde el principio, los equipos de **frontend**, **backend** y otros servicios pueden trabajar en paralelo sin tener que esperar a que una parte de la aplicaci\xf3n est\xe9 completa. Esto no solo acelera el desarrollo, sino que tambi\xe9n reduce los cuellos de botella y los malentendidos, ya que todos trabajan con el mismo contrato API.\\n\\nUn enfoque **API First** permite construir sistemas que son **modulares** y **escalables**. Como las APIs son independientes del resto del sistema, es posible realizar cambios en una parte del sistema sin afectar a otras. Esto es especialmente \xfatil en **arquitecturas de microservicios**, donde diferentes servicios pueden ser desarrollados, desplegados y escalados de manera independiente.\\n\\n:::tip\\nUna **API** no es solo una herramienta t\xe9cnica; es un producto que ser\xe1 utilizado por otros desarrolladores. Por lo tanto, es fundamental dise\xf1ar la **API** teniendo en cuenta la **experiencia del usuario** (en este caso, el desarrollador). Esto implica pensar en la **usabilidad**, la **consistencia**, y la **claridad de la documentaci\xf3n**, as\xed como en proporcionar ejemplos y gu\xedas claras sobre c\xf3mo utilizar la **API**.\\n:::"},{"id":"srp","metadata":{"permalink":"/cursos/blog/srp","source":"@site/blog/2025-05-19-SRP.md","title":"Principio de responsabilidad \xfanica","description":"El principio de responsabilidad \xfanica es uno de los cinco principios de SOLID.","date":"2025-05-19T00:00:00.000Z","tags":[{"inline":false,"label":"Principio de responsabilidad \xfanica","permalink":"/cursos/blog/tags/about-srp","description":"Tutoriales donde se menciona la palabra srp"},{"inline":false,"label":"SOLID","permalink":"/cursos/blog/tags/about-solid","description":"Tutoriales donde se menciona la palabra SOLID"},{"inline":false,"label":"Patrones de software","permalink":"/cursos/blog/tags/about-patron-software","description":"Tutoriales donde se menciona la palabra patrones de desarrollo o dise\xf1o de software"}],"readingTime":1.875,"hasTruncateMarker":true,"authors":[{"name":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","title":"Ing. de Sistemas","url":"https://github.com/jagarciar","page":null,"socials":{"github":"https://github.com/jagarciar"},"imageURL":"https://github.com/jagarciar.png","key":"jeogarod"}],"frontMatter":{"id":"srp","Titule":"Principio de responsabilidad \xfanica","description":"El principio de responsabilidad \xfanica es uno de los cinco principios de SOLID.","authors":["jeogarod"],"sidebar_position":3,"slug":"srp","tags":["srp","solid","patron-software"],"last_update":{"date":"05/19/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"},"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"API First","permalink":"/cursos/blog/api-first"},"nextItem":{"title":"Composici\xf3n de reductores","permalink":"/cursos/blog/composicion-reductores"}},"content":"El **Principio de responsabilidad \xfanica** es el primero de los cinco que componen **SOLID**.\\n\\n:::tip\\n**SOLID** hace referencia a cinco principios que definen un conjunto de **reglas** y **mejores pr\xe1cticas** a seguir durante el dise\xf1o y desarrollo de software\\n:::\\n\\nEste principio establece que un m\xf3dulo o clase debe de tener una sola responsabilidad, cada m\xf3dulo de software debe tener responsabilidad sobre una sola parte de la funcionalidad proporcionada por la aplicaci\xf3n.\\n\\n\x3c!-- truncate --\x3e\\n\\n:::tip\\nEl **Principio de Responsabilidad \xdanica** nos dice que un m\xf3dulo tiene una \xfanica raz\xf3n para cambiar\\n:::\\n\\nLas ventajas de incluir el **Principio de responsabilidad \xfanica** en nuestros proyectos son:\\n\\n1. Facilita la comprensi\xf3n y el mantenimiento del c\xf3digo porque cada m\xf3dulo o clase tiene un prop\xf3sito bien definido.\\n2. Aumenta la reutilizaci\xf3n del c\xf3digo porque los m\xf3dulos pueden reutilizarse en otras partes de la aplicaci\xf3n donde encajen.\\n3. En otras palabras, cada m\xf3dulo o componente debe hacer una sola cosa y hacerla bien. Esto ayuda a mantener el software limpio y f\xe1cil de mantener, ya que es m\xe1s f\xe1cil comprender qu\xe9 est\xe1 pasando si todo est\xe1 dividido en peque\xf1as partes con funciones claramente definidas.\\n\\n## ReactJS\\n\\nSi estamos construyendo una aplicaci\xf3n en **ReactJS** debemos tener en cuenta los siguientes para incluir el **Principio de responsabilidad \xfanica**:\\n\\n- Un componente que renderiza un formulario no deber\xeda ser tambi\xe9n responsable de manejar el env\xedo del mismo. Son dos responsabilidades diferentes y, por lo tanto, violar\xeda la SRP. Un componente solo debe tener un trabajo o responsabilidad.\\n\\n- Una forma de aumentar el nivel de abstracci\xf3n cuando se piensa en los componentes individuales de React es si son de **presentaci\xf3n** o de **contenedor**. Los **componentes de presentaci\xf3n** tienden a no preocuparse demasiado por la l\xf3gica de la aplicaci\xf3n, se centran en el aspecto de las cosas (**HTML/CSS**). Los **componentes contenedores**, sin embargo, se centran principalmente en proporcionar datos y comportamiento a los componentes de presentaci\xf3n (hijos) que se encuentran por debajo en la jerarqu\xeda.\\n\\n- El SRP tambi\xe9n puede aplicarse a nivel de props individuales y variables de estado, cada prop o variable de estado debe ser utilizada s\xf3lo para su prop\xf3sito; si necesita ser cambiada por cualquier otra raz\xf3n, debe ser extra\xedda en su propia prop o variable de estado."},{"id":"composicion-reductores","metadata":{"permalink":"/cursos/blog/composicion-reductores","source":"@site/blog/2025-05-18-Composicion-reducers.md","title":"Composici\xf3n de reductores","description":"Cuando se desea dividir la l\xf3gica para el manejo de datos en un aplicativo ReactJS que hace uso de Redux, se debe usar la composici\xf3n de reductores en lugar de muchos stores.","date":"2025-05-18T00:00:00.000Z","tags":[{"inline":false,"label":"React","permalink":"/cursos/blog/tags/about-react","description":"Tutoriales donde se menciona la palabra react"},{"inline":false,"label":"React JS","permalink":"/cursos/blog/tags/about-react-js","description":"Tutoriales donde se menciona la palabra reactjs"},{"inline":false,"label":"createRoot","permalink":"/cursos/blog/tags/about-createRoot","description":"Tutoriales donde se menciona la palabra createRoot"},{"inline":false,"label":"NPM","permalink":"/cursos/blog/tags/about-npm","description":"Tutoriales donde se menciona la palabra npm"},{"inline":false,"label":"Vite","permalink":"/cursos/blog/tags/about-vite","description":"Tutoriales donde se menciona la palabra vite"},{"inline":false,"label":"Redux","permalink":"/cursos/blog/tags/about-redux","description":"Tutoriales donde se menciona la palabra redux"},{"inline":false,"label":"Estado","permalink":"/cursos/blog/tags/about-estado","description":"Tutoriales donde se menciona la palabra estado"},{"inline":false,"label":"flux","permalink":"/cursos/blog/tags/about-flux","description":"Tutoriales donde se menciona la palabra flux"}],"readingTime":1.515,"hasTruncateMarker":true,"authors":[{"name":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","title":"Ing. de Sistemas","url":"https://github.com/jagarciar","page":null,"socials":{"github":"https://github.com/jagarciar"},"imageURL":"https://github.com/jagarciar.png","key":"jeogarod"}],"frontMatter":{"id":"composicion-reductores","title":"Composici\xf3n de reductores","description":"Cuando se desea dividir la l\xf3gica para el manejo de datos en un aplicativo ReactJS que hace uso de Redux, se debe usar la composici\xf3n de reductores en lugar de muchos stores.","slug":"composicion-reductores","sidebar_position":1,"authors":["jeogarod"],"tags":["react","reactjs","createRoot","npm","vite","redux","estado","flux"],"last_update":{"date":"05/19/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"},"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Principio de responsabilidad \xfanica","permalink":"/cursos/blog/srp"},"nextItem":{"title":"Flux","permalink":"/cursos/blog/flux"}},"content":"Recordemos que [**Redux**](/docs/programacion/reactjs/frameworks/redux.md) esta compuesto de cuatro artefactos principales : las **vistas**, las **acciones**, los **reductores** y el **almac\xe9n**. Las **vistas**  ejecutan las **acciones** a trav\xe9s de los **reductores**. Los **reductores** crean, consultan, actualizan o eliminan datos definidos en el **modelo** y gestionados por el **almac\xe9n**. \\n\\nSeg\xfan la necesidad del negocio, una aplicaci\xf3n puede tener m\xe1s de una entidad en el modelo de datos. Por ejemplo, si nuestra aplicaci\xf3n trata de un sistema autogestionable de productos adquiridos por un cliente en una compa\xf1\xeda, por lo menos, las entidades cliente y productos deber\xedan existir en el modelo de datos. \\n\\n\x3c!-- truncate --\x3e\\n\\nTeniendo en cuenta el ejemplo anterior, podriamos pensar en dos modelos : **initialCustomerState** e **initialProductsState**. \\n\\n```javascript\\nconst initialCustomerState = {\\n    id:0,\\n    name:\\"Jeyson\\",\\n    age:33,\\n    email:\\"jeogarod@gmail.com\\"\\n}\\n\\nconst initialProductsState = [\\n  {\\n    id:0,\\n    name:\\"Salt\\",\\n    value:$300\\n  }\\n]\\n```\\n\\nCada modelo de datos podr\xeda y deber\xeda estar asociado a un reductor. Por ejemplo, **clienteReducer** responder\xeda a los tipos de acci\xf3n asociados al modelo del cliente y **productosReducer** responder\xeda a los tipos de acci\xf3n asociados al modelo de los productos.  \\n\\n```javascript\\nexport const clienteReducer = (state = initialCustomerState, action) => {\\n    switch (action.type) {\\n        case \\"REGISTER_CUSTOMER\\":\\n            return action.payload;\\n\\n        default:\\n            return state\\n    }\\n}\\n```\\n\\n```javascript\\nexport const productosReducer = (state = initialProductsState, action) => {\\n    switch (action.type) {\\n        case \\"ADD_PRODUCTO\\":\\n            return [...productos, action.payload]\\n        default:\\n            return state\\n    }\\n}\\n```\\n\\nCada reductor implementado puede ser combinado creando un \xfanico reductor. Esto se logra a trav\xe9s de **combineReducers**. \\n\\n```javascript\\nimport { createStore, combineReducers } from \'redux\'\\n\\nconst reducer = combineReducers({\\n    cliente: clienteReducer,\\n    productos: productosReducer\\n})\\n```\\n\\nFinalmente durante la creaci\xf3n del **almac\xe9n** se env\xeda como argumento a la funci\xf3n el resultado de la combinaci\xf3n de los reductores. \\n\\n```javascript\\nconst store = createStore(reducer)\\n```\\n\\nEsto va permitir que tengamos organizado nuestro c\xf3digo con varios reductores y un \xfanico almac\xe9n."},{"id":"flux","metadata":{"permalink":"/cursos/blog/flux","source":"@site/blog/2025-05-18-Flux.md","title":"Flux","description":"Flux es un patr\xf3n de arquitectura de datos para aplicaciones web que permiten gestionar el estado.","date":"2025-05-18T00:00:00.000Z","tags":[{"inline":false,"label":"flux","permalink":"/cursos/blog/tags/about-flux","description":"Tutoriales donde se menciona la palabra flux"},{"inline":false,"label":"Patrones de software","permalink":"/cursos/blog/tags/about-patron-software","description":"Tutoriales donde se menciona la palabra patrones de desarrollo o dise\xf1o de software"}],"readingTime":1.595,"hasTruncateMarker":true,"authors":[{"name":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez","title":"Ing. de Sistemas","url":"https://github.com/jagarciar","page":null,"socials":{"github":"https://github.com/jagarciar"},"imageURL":"https://github.com/jagarciar.png","key":"jeogarod"}],"frontMatter":{"id":"flux","Titule":"Flux","description":"Flux es un patr\xf3n de arquitectura de datos para aplicaciones web que permiten gestionar el estado.","authors":["jeogarod"],"sidebar_position":2,"slug":"flux","tags":["flux","patron-software"],"last_update":{"date":"05/19/2025","author":"Jeyson Andr\xe9s Garc\xeda Rodr\xedguez"},"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Composici\xf3n de reductores","permalink":"/cursos/blog/composicion-reductores"}},"content":"**Flux** es una **arquitectura** que asegura que los **datos** en una **aplicaci\xf3n web** fluyan en una sola direcci\xf3n, desde el inicio de un cambio hasta que ese cambio se refleja en la **interfaz de usuario**.\\n\\n**Flux** propone una arquitectura en la que el flujo de datos es unidireccional. Los **datos** viajan desde la **vista** por medio de **acciones** y llegan a un **Store** desde el cual se actualizar\xe1 la vista de nuevo. \\n\\n:::tip\\nLa funci\xf3n principal de **Flux** es gestionar el **estado** de una aplicaci\xf3n, definiendo un **flujo unidireccional de datos**. Esto significa que los datos s\xf3lo pueden fluir en una direcci\xf3n, desde los componentes hacia el estado de la aplicaci\xf3n y luego hacia los componentes nuevamente.\\n:::\\n\\n\x3c!-- truncate --\x3e\\n\\n![Arquitectura Flux](/img/flux.png)\\n\\n**Flux** se compone de diferentes **componentes**, incluyendo el **dispatcher**, las **acciones**, los **almacenes** y las **vistas**. El **dispatcher** es el encargado de recibir y distribuir las **acciones** a los diferentes **almacenes**. Las **acciones** son objetos que contienen informaci\xf3n sobre los **eventos** que ocurren en la aplicaci\xf3n. Los **almacenes** son los encargados de contener y gestionar el **estado** de la aplicaci\xf3n, y las **vistas** muestran la informaci\xf3n al usuario y env\xedan las **acciones** al **dispatcher**.\\n\\nLa principal ventaja de **Flux** es su capacidad para mantener un **flujo de datos unidireccional**, lo que facilita la comprensi\xf3n y depuraci\xf3n del c\xf3digo. Adem\xe1s, separa de manera clara la l\xf3gica de presentaci\xf3n de la l\xf3gica de negocio, lo que facilita el mantenimiento y escalabilidad del c\xf3digo. Tambi\xe9n permite tener un control m\xe1s preciso sobre c\xf3mo se actualiza y cambia el estado de la aplicaci\xf3n, evitando problemas de sincronizaci\xf3n y conflicto de datos.\\n\\n:::tip\\nEste patr\xf3n es com\xfanmente utilizado en aplicaciones desarrolladas con [**React**](/docs/programacion/reactjs/intro.md), un popular framework de JavaScript para la construcci\xf3n de interfaces de usuario interactivas. **Flux** permite manejar de manera efectiva las actualizaciones y cambios en la interfaz de usuario, manteniendo el estado de la aplicaci\xf3n consistente y predecible.\\n:::"}]}}')}}]);